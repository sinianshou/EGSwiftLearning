//
//  AlgorithmManager+DecodeWays2.swift
//  EGSwiftLearning
//
//  Created by Easer Liu on 2020/2/19.
//  Copyright © 2020 Easer. All rights reserved.
//

extension AlgorithmManager {
    func numDecodings(_ s: String) -> Int {
        //字符串一共有多少种解码方式
        var e0:Int64 = 1
        //存储字符串末位为 1 时的编码方式数量
        var e1:Int64 = 0
        //存储字符串末位为 1 时的编码方式数量
        var e2:Int64 = 0
        //临时计算用的容器
        var f0:Int64 = 0
        //模的除数
        let M:Int64 = Int64(1e9 + 7)
        //遍历字符串 s
        for c in s
        {
            if c == "*"
            {
                //由于 * 可以代指 1 ~ 9
                //所以 e0 和 e1 都有九种方式，而最大到 26 所以 e2 只有 6 种
                f0 = 9 * e0 + 9 * e1 + 6 * e2
                //由于 * 可以代指 1 和 2，所以 e1 和 e2 都需要赋值
                e1 = e0
                e2 = e0
            }
            else
            {
                //先计算合并解码的情况
                //当前一位为 1 时，当前位在[0,9]范围内都可以进行合并解码，所以将 e1 加入到容器
                f0 = e1
                //当前一位为 2 时，当前位在[0,6]范围内才可以进行合并解码，将 e2 加入到容器
                if c <= "6"
                {
                    f0 += e2
                }
                
                //计算单独解码
                //如果当前字符为 0 ，则不能进行单独解码
                //所以只有当前位在[1,9]范围内才可以单独解码，将 e0 加入到容器
                if c > "0"
                {
                    f0 += e0
                }
                //依据当前字符是否为 1 或 2 ，来判断是将 e1 e2 为 e0 还是 0
                //以 61616 为例，当循环到 6161 时，当前字符为 1
                //在下次遍历到 6 时，由于会用到 616 和 6161 的结果
                //所以在此次遍历中，将 e0 赋值给 e1
                //这样，e1 中保留的就是 616 的结果，而 6161 的结果可在之后通过 f0 进行计算存储到 e0 中
                //当前字符不为 1 时，则下次遍历不会出现变动，故将 e1 变更为 0
                // e2 也是相同道理
                e1 = c == "1" ? e0 : 0
                e2 = c == "2" ? e0 : 0
            }
            //本次循环中，用 f0 % M 得出结果 e0
            e0 = f0 % M
        }
        //返回结果
        return Int(e0)
    }
}
